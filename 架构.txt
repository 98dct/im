项目架构：
api模块：充当BFF层，作为网关的后端
rpc模块：被api模块调用

项目目录结构：
apps:   应用目录，记录相关服务信息
- user:
    - api:
    - rpc:
- im
deploy          项目部署相关信息 sql or dockerfile
pkg
docker-compose.yaml
Makefile      编译脚本

网关的作用：
1.反向代理、负载均衡
2.请求转发，根据不同的请求路径、请求头转发到不同的后端服务
3.支持不同的协议转换  http到websocket、grpc
4.认证、授权
5.熔断、限流、重试

项目三大业务
用户：
    登入、注册、详情、查找
社交【好友、群】：
    好友：好友添加(好友申请、好友申请处理)、好友列表
    群：进群、退群、列表
聊天：
    私聊、群聊、聊天记录
    消息已读、未读
    历史/在线/离线消息
    用户在线/离线状态

基础环境：
机器：
    虚拟机：192.168.8.100
代码仓库：
    github托管
镜像仓库：
   阿里云个人镜像仓库
   docker pull xxx 时根据是否指定仓库地址决定从私有仓库还是公共仓库拉取镜像

chmod 777 -R ./components  递归给目录赋予权限
docker run -d --name xxx --restart=always  nginx:latest   指定容器自动重启
docker update --restart=always xxx      更新容器为自动重启

md5加密：不加盐的单向hash，不可逆，同一个密码经过hash后生成同一个hash值(32位)，加密速度快
bcrypt加密：加盐、加cost的单向hash，不可逆，同一密码每次加密后生成的值都不一样(60位)，加密速度慢

一致性级别：
强一致性：金融交易、在线支付
弱一致性：网站评论、社交平台
最终一致性：数据复制、同步、日志统计

先删除缓存、后更新数据、
延迟双删：先删缓存、在删数据库、等待N秒、再删缓存
第二次删缓存可以用异步执行，配合重试机制使用

先更新数据、后删除缓存


最终一致性：
先更新数据库、然后将删除缓存的动作放到异步任务队列中去执行，缺点：代码耦合
先更新数据库、然后使用cannel监听binlog日志，在删除缓存，优点：无代码耦合


建立两个人的好友关系，怎样存储关系？
1.冗余存储，A--B B--A 好处：简单明了，查询快速，缺点：存在冗余
2.计算唯一key, A,B的user id合成一个唯一key，根据key查询

go-zero內部采用grpc来作为rpc通信，使用etcd作为注册、发现中心
grpc采用去中心化思想，在客户端实现负载均衡
zookeeper：
优点：基于java开发、服务稳定，功能齐全
缺点：复杂度大、维护难度大，比较重
etcd: 使用go语言开发，采用键值对存储数据，是一个分布式，强一致性，具有监听机制的配置系统
consul: 使用go语言开发，支持键值对、列表和树等多种数据结构，提供服务发现和健康检查机制
是中心化的服务发现系统。

客户端发现：etcd，客户端从注册中心获取服务端服务列表信息，客户端内部实现负载均衡机制。
中心化发现：consul，客户端只需要知道中心的地址，有中心实现负载均衡。

无状态负载均衡：
有状态负载均衡：相比有状态多了请求-响应数据的记录和数据的计算

轮询、随机、哈希、权重

go-zero采用p2c + EWMA

im通讯服务架构：im-api、im-ws、im-rpc
im服务业务：
发送对象：群、好友
消息情况：在线消息、离线消息、已读未读
消息特性：时序性、只增不删
聊天栏：消息联系列表、消息数量

im服务业务重点：聊天记录、聊天会话列表


im服务是一旦登录成功，客户端就需要与服务端建立websocket连接

websocket是一种全双工通信协议，客户端和服务端可以同时发送数据，采用长连接通信，基于事件驱动
(提供一组事件接口，客户端和服务端可以监听特定事件(onOpen、onMessage、onClose、onError)，并做出响应)，
适用于实时通信的场景
具体为：im聊天、数据变化要求实时性的场景、消息推送通知

websocket服务重点：
server对象模型建立、路由建立(method与handler的映射)、鉴权设计(jwt鉴权，获取登录用户)、连接存储

单聊；
推模式：服务端主动推送消息给客户端
拉模式：客户端主动轮询服务端获取消息

读扩散：当用户 A 向一个聊天群组发送消息时，系统只需要将这条消息写入群组存储。
当群组成员需要读取消息时，系统会动态地将消息分发给对应的用户。
写扩散：当用户 A 向一个聊天群组发送消息时，系统会将这条消息写入到群组中每个成员的消息队列或消息存储。
每个成员可以直接从自己的存储读取到消息。

im消息收发模型：通过kafka解耦
消息可靠性：传输保障、确认机制、重试机制、消息顺序保障
ack确认

消息收发ack机制
客户端发送消息，服务端返回ack
服务端发送消息，客户端返回ack
应答ack的方式：
不采用ack机制；
只进行一次应答；
三次通信(tcp握手)保障消息的可靠性。

消息投递方式：
    在线消息：服务端将一个客户端发送到过来的消息直接转发给另一个客户端
    离线消息：服务端将一个客户端发送到过来的消息存入离线数据库中，另一个客户端登录后，在从离线数据库中获取最新消息
消息类别：
    离线消息:
    历史消息：存储了所有的用户聊天消息

采用用户会话列表的方式

im rpc模块：获取聊天消息、获取会话列表、更新会话、建立会话
测试流程：建立会话、获取会话列表、更新会话、获取聊天消息、更新会话列表

